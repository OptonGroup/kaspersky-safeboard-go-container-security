You are an AI Pair Programming Assistant with extensive expertise in backend software engineering. Your knowledge spans a wide range of technologies, practices, and concepts commonly used in modern backend systems.
You are also an expert in Go programming language and have a deep understanding of the Go runtime and the standard library.
### План реализации сервиса внутренней очереди задач на Go

Шаг 1. Каркас проекта и конфигурация
- Создать `go.mod` (Go 1.24), выбрать имя модуля
- Завести структуру каталогов: `cmd/server`, `internal/queue`, `internal/http`
- Реализовать загрузку конфигурации из env: `WORKERS` (по умолчанию 4), `QUEUE_SIZE` (по умолчанию 64)
- Инициализировать HTTP-сервер и маршруты-заглушки: `POST /enqueue`, `GET /healthz`
- Добавить обработку сигналов `SIGINT`/`SIGTERM`, контекст и `WaitGroup`

Шаг 2. Модель задачи и состояния
- Определить тип `Task`: `ID`, `Payload`, `MaxRetries`, `Attempt`, `Status`, `CreatedAt`, `UpdatedAt`
- Задать константы статусов: `queued`, `running`, `done`, `failed`
- Хранилище состояний в памяти: `map[string]Task` + `sync.RWMutex`
- Вспомогательные функции: создать/обновить задачу, получить состояние по `ID`

Шаг 3. Очередь и приём задач
- Создать буферизированный канал задач размера `QUEUE_SIZE`
- Обработчик `POST /enqueue`:
  - Валидировать JSON-вход
  - Инициализировать `Task` со статусом `queued`
  - Неблокирующе положить в очередь; если полна — вернуть 503
  - Обновить/сохранить состояние задачи в памяти
- Защитить приём задач флагом «accepting» для graceful shutdown

Шаг 4. Пул воркеров и обработка
- Поднять `WORKERS` горутин-воркеров, читающих из очереди до остановки контекста
- Перед началом обработки выставлять статус `running`
- Симулировать обработку: `100–500ms` `time.Sleep`
- С вероятностью ~20% возвращать ошибку обработки

Шаг 5. Повторы с экспоненциальным бэкоффом и джиттером
- При ошибке: если `Attempt < MaxRetries` — рассчитать бэкофф: `base*2^attempt + jitter`
- Реализовать `jitter` (например, `0–100ms`), `base` (например, `200ms`)
- После ожидания попытаться повторно положить задачу в очередь:
  - С `select` по контексту; при полной очереди — повторять попытку неблокирующе с небольшим `sleep`
- Если попытки исчерпаны — статус `failed`; при успехе — `done`

Шаг 6. Healthcheck
- `GET /healthz` возвращает `200 OK`, пустое тело
- Хендлер не зависит от очереди и всегда готов

Шаг 7. Корректное завершение
- По сигналу: прекратить приём новых задач (сбросить `accepting`/закрыть вход)
- Остановить HTTP-сервер (`Shutdown(ctx)`)
- Дождаться завершения текущих задач (`WaitGroup`), отменить контекст для воркеров/ретраев
- Гарантировать отсутствие «утёкших» таймеров/горутин

Шаг 8. Документация
- Краткое описание в `README.md`: архитектура, конфигурация, как запустить, примеры `curl`
- Описать стратегию бэкоффа и допущения (in-memory, без персистентности)

Шаг 9. Минимальные проверки
- Юнит-тест бэкофф-функции и вероятностной ошибки (детерминированный `rand` через сид)
- Простая интеграция: enqueue нескольких задач, проверка финальных статусов

Шаг 10. (Опционально) Расширения
- `GET /status/{id}` для запроса состояния задачи
- Метрики в памяти: счётчики по статусам
- Логирование событий обработки

Как работать вместе по шагам
- Вы присылаете: «Запускаем Шаг N: <подзадача>» — я выполняю и отчитываюсь
- После каждого шага: краткий отчёт, что изменено, что проверить
- Можно дробить шаг на подзадачи: присылайте одну-две подзадачи за раз

Раздел: Тестирование и CI
- Политика тестирования: для КАЖДОГО шага добавлять соответствующие тесты (только стандартная библиотека `testing`).
  - Шаг 1: тесты загрузки конфигурации из env (значения по умолчанию и переопределение), базовый запуск HTTP с роутами-заглушками.
  - Шаг 2: тесты модели `Task` и хранилища: создание, обновление, чтение, статусы.
  - Шаг 3: тесты `POST /enqueue`: валидация JSON, статус `queued`, поведение при полной очереди (503), флаг `accepting`.
  - Шаг 4: тесты пула воркеров: переходы статусов в `running/done/failed` (детерминировать `rand.Seed`), параллельная обработка без гонок (с `-race`).
  - Шаг 5: юнит-тест функции экспоненциального бэкоффа и джиттера (проверка границ и роста), повторная постановка в очередь по контексту.
  - Шаг 6: тест `GET /healthz` → `200 OK` и независимость от очереди.
  - Шаг 7: интеграционный тест graceful shutdown: остановка приёма, ожидание завершения, отсутствие «утёкших» горутин/таймеров.
  - Шаги 8–10: проверка наличия README/метрик/логов при включении.
- Настроить GitHub Actions для автоматического прогона тестов:
  - Файл `.github/workflows/ci.yml`.
  - Триггеры: `push`, `pull_request` на все ветки.
  - Среда: `actions/setup-go@v5` с `go-version: '1.24'`.
  - Шаги: `checkout`, `setup-go`, кэш модулей, `go vet ./...`, `go test ./... -race -coverprofile=coverage.out -covermode=atomic`.
  - Артефакты: загрузка `coverage.out` (опционально), бейдж статуса (опционально).